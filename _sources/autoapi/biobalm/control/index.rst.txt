biobalm.control
===============

.. py:module:: biobalm.control

.. autoapi-nested-parse::

   This module implementes methods for permanent target control of Boolean networks
   based on the structure of a succession diagram.



Attributes
----------

.. autoapisummary::

   biobalm.control.BooleanSpace
   biobalm.control.ControlOverrides
   biobalm.control.SubspaceSuccession


Classes
-------

.. autoapisummary::

   biobalm.control.SuccessionDiagram
   biobalm.control.Intervention


Functions
---------

.. autoapisummary::

   biobalm.control.is_subspace
   biobalm.control.percolate_space
   biobalm.control.succession_control
   biobalm.control.successions_to_target
   biobalm.control.drivers_of_succession
   biobalm.control.find_drivers
   biobalm.control.controls_are_equal


Module Contents
---------------

.. py:function:: is_subspace(x: biobalm.types.BooleanSpace, y: biobalm.types.BooleanSpace) -> bool

   Checks if `x` is a subspace of `y`.

   :param x: The first space.
   :type x: BooleanSpace
   :param y: The second space.
   :type y: BooleanSpace

   :returns: `True` if `x` is a subspace of `y`.
   :rtype: bool


.. py:function:: percolate_space(network: biodivine_aeon.AsynchronousGraph, space: biobalm.types.BooleanSpace) -> biobalm.types.BooleanSpace

   Percolates a space through a Boolean network.

   Takes a symbolic `AsynchronousGraph` and a `BooleanSpace`. It then percolates
   any values that are effectively constant within the `network` assuming the variables
   from `space` are fixed accordingly.

   If the argument is a trap space, then the result is a subspace of the
   argument and is also a trap space.

   However, when the argument is a general space, the percolation can actually
   lead "outside" of the original space. In such case, the original fixed value
   is *not* modified and the conflict will remain in the resulting space.

   :param network: A symbolic representation of the Boolean network (from which state
                   transitions can be generated) in which the percolation is performed. If
                   needed, an `AsynchronousGraph` object can be constructed from a
                   `BooleanNetwork` via `biodivine_aeon.AsynchronousGraph(bn)`.
   :type network: AsynchronousGraph
   :param space: The space to percolate.
   :type space: BooleanSpace

   :returns: The percolated space.
   :rtype: BooleanSpace


.. py:class:: SuccessionDiagram(network: biodivine_aeon.BooleanNetwork, config: biobalm.types.SuccessionDiagramConfiguration | None = None)

   Succession diagram of a Boolean network.

   This encodes relationships between minimal trap spaces and can be used for
   attractor detection and control. Note that the succession diagram is
   expanded lazily, so it is not built until `build` or a similar method is
   called.


   .. rubric:: Examples

   >>> import biobalm
   >>> sd = biobalm.SuccessionDiagram.from_rules("""
   ...     A, B
   ...     B, A & C
   ...     C, !A | B
   ... """)
   >>> print(sd.summary()) # not built yet!
   Succession Diagram with 1 nodes and depth 0.
   State order: A, B, C
   <BLANKLINE>
   Attractors in diagram:
   <BLANKLINE>
   >>> sd.build()
   >>> print(sd.summary()) # now it's built
   Succession Diagram with 3 nodes and depth 1.
   State order: A, B, C
   <BLANKLINE>
   Attractors in diagram:
   <BLANKLINE>
   minimal trap space 001
   ...................001
   <BLANKLINE>
   minimal trap space 111
   ...................111
   <BLANKLINE>


   .. py:attribute:: network
      :type:  biodivine_aeon.BooleanNetwork

      The Boolean network represented as a `biodivine_aeon.BooleanNetwork` object.


   .. py:attribute:: symbolic
      :type:  biodivine_aeon.AsynchronousGraph

      The symbolic representation of the network using `biodivine_aeon.AsynchronousGraph`.


   .. py:attribute:: petri_net
      :type:  networkx.DiGraph

      The Petri net representation of the network (see :mod:`petri_net_translation<biobalm.petri_net_translation>`).


   .. py:attribute:: nfvs
      :type:  list[str] | None
      :value: None


      The negative feedback vertex set of `SuccessionDiagram.network`, or `None` if not computed yet.


   .. py:attribute:: dag
      :type:  networkx.DiGraph

      The directed acyclic graph (DAG) representation of the succession
      diagram structure.


   .. py:attribute:: node_indices
      :type:  dict[int, int]

      A dictionary mapping subspace keys to their positions in the succession
      diagram (see :func:`biobalm.space_utils.space_unique_key`).


   .. py:method:: default_config() -> biobalm.types.SuccessionDiagramConfiguration
      :staticmethod:



   .. py:method:: from_rules(rules: str, format: Literal['bnet', 'aeon', 'sbml'] = 'bnet', config: biobalm.types.SuccessionDiagramConfiguration | None = None) -> SuccessionDiagram
      :staticmethod:


      Generate a succession diagram from the given string.

      :param rules: The string representation of the network rules.
      :type rules: str
      :param format: The format of the string. One of `"bnet"`, `"aeon"`, or `"sbml"`.
                     Defaults to `"bnet"`.
      :type format: Literal['bnet', 'aeon', 'sbml']
      :param config: An optional configuration object with internal settings
                     and default values.
      :type config: SuccessionDiagramConfiguration | None

      :returns: The generated succession diagram. Initially unexpanded.
      :rtype: SuccessionDiagram



   .. py:method:: from_file(path: str, config: biobalm.types.SuccessionDiagramConfiguration | None = None) -> SuccessionDiagram
      :staticmethod:


      Read a `BooleanNetwork` from the given file path. The format is automatically inferred from
      the file extension.

      Optionally, you can also supply a configuration object to customize the
      resulting succession diagram.



   .. py:method:: expanded_attractor_candidates() -> dict[int, list[biobalm.types.BooleanSpace]]

      Attractor candidates for each expanded node. The candidate list is
      computed for nodes where it is not known yet.

      Collectively, for every attractor in every expanded node, this returns
      at least one candidate state for said attractor. However, for complex
      attractors, there can be more than one candidate state, and there can
      be candidates that are not contained in any attractor.

      *If called before the `SuccessionDiagram` is fully built, this will not
      be a complete accounting of attractors, since any node that isn't expanded
      is not included in the result.*

      .. seealso::

         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_seeds>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_sets>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_candidates>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_seeds>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_sets>`

      :returns: Each key is the id of an expanded succession diagram node, whose
                corresponding value is a list of attractor candidates for that node. Note
                that one succession diagram node can have multiple attractors. Ordering
                of the lists in the returned dictionary is not guaranteed.
      :rtype: dict[int,list[BooleanSpace]]

      .. rubric:: Example

      >>> import biobalm
      >>> sd = biobalm.SuccessionDiagram.from_rules("""
      ...     A, B
      ...     B, A & C
      ...     C, !A | B
      ... """)
      >>> sd.build()
      >>> eas = sd.expanded_attractor_candidates()
      >>> for id, atts in sorted(eas.items()):
      ...     for x in atts:
      ...         print(f"{id}: {dict(sorted(x.items()))}")
      1: {'A': 0, 'B': 0, 'C': 1}
      2: {'A': 1, 'B': 1, 'C': 1}



   .. py:method:: expanded_attractor_seeds() -> dict[int, list[biobalm.types.BooleanSpace]]

      Attractor seeds for each expanded node. The seed list is
      computed for nodes where it is not known yet.

      Collectively, for every attractor in every expanded node, this returns
      exactly one seed state for said attractor.

      *If called before the `SuccessionDiagram` is fully built, this will not
      be a complete accounting of attractors, since any node that isn't expanded
      is not included in the result.*

      .. seealso::

         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_candidates>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_sets>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_candidates>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_seeds>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_sets>`

      :returns: Each key is the id of an expanded succession diagram node, whose
                corresponding value is a list of attractor seeds for that node. Note
                that one succession diagram node can have multiple attractors. Ordering
                of the lists in the returned dictionary is not guaranteed.
      :rtype: dict[int,list[BooleanSpace]]

      .. rubric:: Example

      *Note that for this simple network, attractor candidates and attractor
      seeds are the same states.*

      >>> import biobalm
      >>> sd = biobalm.SuccessionDiagram.from_rules("""
      ...     A, B
      ...     B, A & C
      ...     C, !A | B
      ... """)
      >>> sd.build()
      >>> eas = sd.expanded_attractor_seeds()
      >>> for id, atts in sorted(eas.items()):
      ...     for x in atts:
      ...         print(f"{id}: {dict(sorted(x.items()))}")
      1: {'A': 0, 'B': 0, 'C': 1}
      2: {'A': 1, 'B': 1, 'C': 1}



   .. py:method:: expanded_attractor_sets() -> dict[int, list[biodivine_aeon.VertexSet]]

      Attractor sets for each expanded node. The sets are
      computed for nodes where they are not known yet.

      These sets represent the complete collection of attractor states in each
      expanded node. For fixed-point attractors, this is effectively equivalent
      to the attractor seeds. For complex attractors, this set contains the
      full attractor. Hence, it is harder to compute but can facilitate richer
      post-processing and analysis.

      *If called before the `SuccessionDiagram` is fully built, this will not
      be a complete accounting of attractors, since any node that isn't expanded
      is not included in the result.*

      .. seealso::

         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_candidates>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.expanded_attractor_seeds>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_candidates>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_seeds>`
         - :meth:`expanded_attractor_seeds<SuccessionDiagram.node_attractor_sets>`

      :returns: Each key is the id of an expanded succession diagram node, whose
                corresponding value is a list of attractor sets for that node. Note
                that one succession diagram node can have multiple attractors. Ordering
                of the lists in the returned dictionary is not guaranteed.
      :rtype: dict[int,list[biodivine_aeon.VertexSet]]

      .. rubric:: Example

      >>> import biobalm
      >>> sd = biobalm.SuccessionDiagram.from_rules("""
      ...     A, B
      ...     B, A & C
      ...     C, !A | B
      ... """)
      >>> sd.build()
      >>> eas = sd.expanded_attractor_sets()
      >>> for id, atts in sorted(eas.items()):
      ...     for x in atts:
      ...         print(f"{id}: {x}")
      1: VertexSet(cardinality=1, symbolic_size=5)
      2: VertexSet(cardinality=1, symbolic_size=5)



   .. py:method:: summary() -> str

      Return a summary of the succession diagram as a string.



   .. py:method:: root() -> int

      Return the ID of the root node.



   .. py:method:: depth() -> int

      Compute the maximal node depth in the diagram.

      Depth is counted from zero (root has depth zero).



   .. py:method:: node_ids() -> Iterator[int]

      Iterator over all available node IDs.



   .. py:method:: stub_ids() -> Iterator[int]

      Iterator over all node IDs that are currently *not* expanded.



   .. py:method:: expanded_ids() -> Iterator[int]

      Iterator over all node IDs that are currently expanded.



   .. py:method:: minimal_trap_spaces() -> list[int]

      List of node IDs that represent the minimal trap spaces within this
      succession diagram.

      Note that stub nodes do not count as minimal!



   .. py:method:: find_node(node_space: biobalm.types.BooleanSpace) -> int | None

      Return the ID of the node matching the provided `node_space`, or `None`
      if no such node exists in this succession diagram.

      :param node_space: The space of the node to find.
      :type node_space: BooleanSpace

      :returns: The ID of the node matching the provided `node_space`, or `None`
                if no such node exists in this succession diagram.
      :rtype: int | None



   .. py:method:: is_subgraph(other: SuccessionDiagram) -> bool

      Returns `True` if this succession diagram is a subgraph of the `other`
      succession diagram.

      Note that this function works even for diagrams based on different
      Boolean networks, as long as both succession diagrams only depend on the
      same subset of network variables.

      WARNING: This does not take into account the stable motifs on individual
      edges. Just the subspaces associated with nodes and the presence of
      edges between nodes.

      :param other: The other succession diagram.
      :type other: SuccessionDiagram

      :returns: `True` if this succession diagram is a subgraph of the `other`
                succession diagram.
      :rtype: bool



   .. py:method:: is_isomorphic(other: SuccessionDiagram) -> bool

      Returns `True` if the two succession diagrams are isomorphic.

      Note that this function works even for diagrams based on different
      Boolean networks, as long as both succession diagrams only depend on the
      same subset of network variables.

      WARNING: This does not take into account the stable motifs on individual
      edges. Just the subspaces associated with nodes and the presence of
      edges between nodes.

      :param other: The other succession diagram.
      :type other: SuccessionDiagram

      :returns: `True` if the two succession diagrams are isomorphic.
      :rtype: bool



   .. py:method:: node_data(node_id: int) -> biobalm.types.NodeData

      Get the data associated with the provided `node_id`.

      Returns a `NodeData` object with the following attributes:

      - `depth`: The depth of the node.
      - `space`: The sub-space of the node.
      - `expanded`: Whether the node is expanded or not.
      - `percolated_network`: [`None` if not computed] The percolation of
      `SuccessionDiagram.network` with respect to the node's `space`.
      - `percolated_petri_net`: [`None` if not computed] The percolation of
      `SuccessionDiagram.petri_net` with respect to the node's `space`.
      - `percolated_nfvs`: [`None` if not computed] The NFVS of `percolated_network`.
      - `attractor_candidates`: [`None` if not computed] A collection of states
      that collectively cover every attractor of this node.
      - `attractor_seeds`: [`None` if not computed] A collection of states
      one-to-one corresponding to the attractors of this node.
      - `attractor_sets`: [`None` if not computed] A complete collection of
      attractors of this node.

      See :class:`biobalm.types.NodeData` for more information.

      :param node_id: The ID of the node.
      :type node_id: int

      :returns: The data associated with the provided `node_id`. Note that at
                runtime, this object is an untyped dictionary.
      :rtype: NodeData



   .. py:method:: reclaim_node_data()

      Removes non-essential data from the `NodeData` dictionary of each node.

      This method can be used to reduce the memory footprint of the succession
      diagram, especially before serialization. However, note that this can
      also slow down subsequent computations if the erased data needs
      to be re-computed.

      The method removes the `percolated_network`, `percolated_petri_net`,
      and the `percolated_nfvs`. Furthermore, if `attractor_seeds` are known,
      it erases the `attractor_candidates`, since seeds can be used for the
      same tasks.



   .. py:method:: node_is_minimal(node_id: int) -> bool

      True if the node represents a minimal trap space.

      :param node_id: The ID of the node.
      :type node_id: int

      :returns: `True` if the node is expanded and it has no successors, i.e. it is a
                minimal trap space.
      :rtype: bool



   .. py:method:: node_successors(node_id: int, compute: bool = False) -> list[int]

      Return the successor nodes for the given `node_id`.

      If the node is already expanded, known results are simply returned. If
      the node is not expanded, but `compute` is set to `True`, then the node
      is expanded and the newly computed results are returned. If the node is
      not expanded and `compute` is set to `False`, the method raises a
      `KeyError` exception.

      The default behaviour intentionally does not compute successors to
      prevent "accidental complexity".

      WARNING: We do not guarantee the order of the returned nodes. If you
      need the successors in a repeatable order, you should sort the list
      manually.

      Also note that if the given `node_id` already has associated attractor
      data but is not expanded, this data will be deleted as it is no longer
      up to date.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the successors if they are not already known.
      :type compute: bool

      :returns: The list of successor node ids.
      :rtype: list[int]



   .. py:method:: node_attractor_candidates(node_id: int, compute: bool = False, greedy_asp_minification: bool = True, simulation_minification: bool = True, pint_minification: bool = False) -> list[biobalm.types.BooleanSpace]

      Return the list of attractor candidate states for the given `node_id`.

      If attractor candidates are not computed but seeds are, returns
      attractor seeds, as these are also valid as candidate states, but
      even more precise.

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag. If `compute` is set to `True`, additional flags can be used
      to adjust the candidate identification process (see *Parameters*).

      Note that you can compute attractor candidates for nodes that are not expanded,
      but (a) multiple unexpanded nodes can contain the same attractor, and hence also
      the same/similar candidates (i.e. you can "discover" the same attractor in multiple
      unexpanded nodes, if the nodes intersect), and (b) this data is erased if the
      node is later expanded.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the attractor candidates if they are not already known.
      :type compute: bool
      :param greedy_asp_minification: Indicate that the initial candidate set should be first greedily minified
                                      through repeated ASP queries. [Default: True]
      :type greedy_asp_minification: bool
      :param simulation_minification: Indicate that the candidate set should be refined through stochastic
                                      simulation. [Default: True]
      :type simulation_minification: bool
      :param pint_minification: Indicate that the candidate set should be refined through reachability
                                analysis using `pint`. Only enable this option if you actually have `pint`
                                installed (it is an optional dependency). [Default: False]
      :type pint_minification: bool

      :returns: The list of attractor candidate states.
      :rtype: list[BooleanSpace]



   .. py:method:: node_attractor_seeds(node_id: int, compute: bool = False) -> list[biobalm.types.BooleanSpace]

      Return the list of attractor seed states for the given `node_id`.

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag.

      Note that the same considerations regarding attractors in unexpanded
      nodes apply as for :meth:`node_attractor_candidates`.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the attractor seeds if they are not already known.
      :type compute: bool

      :returns: The list of attractor seed states.
      :rtype: list[BooleanSpace]



   .. py:method:: node_attractor_sets(node_id: int, compute: bool = False) -> list[biodivine_aeon.VertexSet]

      Return the list of attractor sets for the given `node_id`.

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag.

      Note that the same considerations regarding attractors in unexpanded
      nodes apply as for :meth:`node_attractor_candidates`.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the attractor sets if they are not already known.
      :type compute: bool

      :returns: The list of attractor sets.
      :rtype: list[biodivine_aeon.VertexSet]



   .. py:method:: node_percolated_nfvs(node_id: int, compute: bool = False) -> list[str]

      Approximate minimum negative feedback vertex set on the Boolean network
      percolated to the node's sub-space.

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag.

      See :func:`biobalm.interaction_graph_utils.feedback_vertex_set` for
      further details.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the node NFVS if it is not already known.
      :type compute: bool

      :returns: The negative feedback vertex set, as a list of node names.
      :rtype: list[str]



   .. py:method:: node_percolated_network(node_id: int, compute: bool = False) -> biodivine_aeon.BooleanNetwork

      The Boolean network percolated to the node's sub-space, with
      constant variables removed.

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the node NFVS if it is not already known.
      :type compute: bool

      :returns: The percolated Boolean network.
      :rtype: biodivine_aeon.BooleanNetwork



   .. py:method:: node_percolated_petri_net(node_id: int, compute: bool = False, parent_id: int | None = None) -> networkx.DiGraph

      The Petri net representation of the Boolean network percolated to the
      node's sub-space (with constant variables removed).

      Similar to :meth:`node_successors`, the method either computes the
      data if unknown, or throws an exception, depending on the `compute`
      flag.

      :param node_id: The ID of the node.
      :type node_id: int
      :param compute: Whether to compute the node NFVS if it is not already known.
      :type compute: bool
      :param parent_id: If given, the percolation process starts with the Petri net of the given
                        parent node (if computed). If parent is not given, the percolation starts
                        with `SuccessionDiagram.petri_net`, which can be slower but yields the
                        same result.
      :type parent_id: int | None

      :returns: The percolated Boolean network.
      :rtype: networkx.DiGraph



   .. py:method:: edge_stable_motif(parent_id: int, child_id: int, reduced: bool = False) -> biobalm.types.BooleanSpace

      Return the stable motif for the given parent-child edge.

      If `reduced` is set to `False` (default), the unpercolated stable
      motif trap space corresponding to the child node is returned; this
      includes the nodes that are fixed in the percolated trap space of the
      parent node. If `reduced` is set to `True`, the nodes fixed in the
      parent are removed (and thus the reduced stable motif is not a trap
      space of the original network, but is a maximal trap space in the
      network reduced by the parent node).

      :param parent_id: The ID of the parent node.
      :type parent_id: int
      :param child_id: The ID of the child node.
      :type child_id: int
      :param reduced: Whether to return the reduced stable motif.
      :type reduced: bool

      :returns: The stable motif (maximal trap space) represented by the edge.
      :rtype: BooleanSpace



   .. py:method:: component_subdiagram(component_variables: list[str], node_id: int | None = None) -> SuccessionDiagram

      Return an *unexpanded* `SuccessionDiagram` that is restricted to
      a subnetwork induced by the provided `component_variables`.  Furthermore,
      If `node_id` is given, the subnetwork is first percolated to the
      subspace of the specified node.

      The `component_variables` must be backward-closed in the considered network
      (i.e. either the full network, or the percolated network if `node_id` is given),
      meaning there is no variable outside this list that regulates any variable in the
      subnetwork. If this is not satisfied, the function will fail while
      creating the subnetwork.

      Also note that the symbolic encoding of the new network is not
      compatible with the encoding of the original network, because the
      underlying networks have different sets of variables.

      :param component_variables: Names of variables which induce the subnetwork of the resulting
                                  succession diagram.
      :type component_variables: list[str]
      :param node_id: The ID of a succession diagram node that will define a subspace
                      to which the subnetwork is percolated. If not given, the full
                      network is considered.
      :type node_id: int | None

      :returns: An unexpanded succession diagram of the subnetwork.
      :rtype: SuccessionDiagram



   .. py:method:: source_scc_subdiagrams(node_id: int | None = None) -> Iterator[SuccessionDiagram]

      Return unexpanded subdiagrams for the source SCCs in a node subspace.

      Note that the symbolic encoding of the new network is not
      compatible with the encoding of the original network, because the
      underlying networks have different sets of variables.

      :param node_id: The ID of a succession diagram node that will define a subspace on
                      which the subnetworks should be considered. By default, the root node
                      is used.
      :type node_id: int | None

      :returns: An iterator over unexpanded succession diagrams of the subnetwork.
      :rtype: Iterator[SuccessionDiagram]



   .. py:method:: build()

      Expand the succession diagram and search for attractors using default methods.



   .. py:method:: expand_scc(find_motif_avoidant_attractors: bool = True) -> bool

      Expand the succession diagram using the source SCC method.



   .. py:method:: expand_block(find_motif_avoidant_attractors: bool = True) -> bool

      Expand the succession diagram using the source block method.

      There is a minor difference in behavior depending on `find_motif_avoidant_attractors`.
      If set to `False`, the expansion only expands one "source block" for each node,
      without checking any attractor properties. If set to `True`, the expansion might
      expand some nodes fully to uncover nodes that precisely cover motif
      avoidant attractors.



   .. py:method:: expand_bfs(node_id: int | None = None, bfs_level_limit: int | None = None, size_limit: int | None = None) -> bool

      Explore the succession diagram in a BFS manner.

      If `node_id` is given, initiate BFS from this node. Otherwise use root.
      If `bfs_level_limit` is given, this is the last "level" (distance from
      the initial node) of nodes that should be expanded (any subsequent child
      nodes are left unexplored).

      If `size_limit` is given, the procedure stops once `SuccessionDiagram`
      exceeds the given size.

      With default settings, the method will explore the whole succession
      diagram without any restrictions.

      The method returns `True` if the whole exploration was completed and
      `False` if it was terminated early based on one of the aforementioned
      conditions.

      Note that the procedure also explores nodes that are already expanded.
      I.e. if all nodes at levels 0,1,2 are expanded, but there are stub nodes
      on level 3, the procedure will still discover and expand these stub
      nodes (assuming sufficient level and size limit).

      Also note that the `size_limit` is only a soft limit: for each node, we
      always have to create all child nodes when expanding it. Hence the
      procedure can only check the condition in between expanding new nodes.



   .. py:method:: expand_dfs(node_id: int | None = None, dfs_stack_limit: int | None = None, size_limit: int | None = None) -> bool

      Similar to `expand_bfs`, but uses DFS instead of BFS.

      The only major difference is the `dfs_stack_limit` which restricts the
      size of the DFS stack. Nodes that would appear "deeper" in the stack
      than this limit are left unexpanded. Note that this stack size is
      technically *some* form of distance from the initial node, but not
      necessarily the minimal distance.



   .. py:method:: expand_minimal_spaces(size_limit: int | None = None) -> bool

      Expands the succession diagram in a way that guarantees every minimal
      trap space to be reachable from the root node, but otherwise (greedily)
      avoids unnecesary expansion of nodes whenever possible.

      The algorithm is loosely based on `expand_bfs` implementation, but on
      each BFS level only expands the first node that still contains some
      minimal trap space not covered by a previously expanded node at that
      level.

      The resulting succession diagram construction is deterministic, but can
      vary if some nodes are already expanded initially. In such case, the
      procedure still tries to avoid expanding unnecessary nodes, which means
      existing expanded nodes can be prioritised over the "canonical" ones.



   .. py:method:: expand_attractor_seeds(size_limit: int | None = None) -> bool

      Expands the succession diagram such that for every asynchronous
      attractor, there is at least one expanded trap space which is the
      minimal trap space containing this attractor. In other words, the
      procedure expands the succession diagram as little as possible, but
      ensures that every attractor is "as easy to identify" as possible.

      After this procedure, it is sufficient to search for attractors in
      expanded nodes. Note that this method does not perform exact attractor
      identification. It is possible that some nodes are expanded spuriously
      and the succession diagram is thus larger than necessary.



   .. py:method:: expand_to_target(target: biobalm.types.BooleanSpace, size_limit: int | None = None) -> bool

      Expands the succession diagram using BFS in such a way that only nodes
      which intersect `target` but are not fully contained in it are expanded.

      This is used for example in control, as it ensures that all possible
      branches of the succession diagram relevant for a particular "target
      subspace" are expanded as much as necessary, but not more.



.. py:data:: BooleanSpace
   :type:  TypeAlias
   :value: dict[str, Literal[0, 1]]


   Type alias for `dict[str, Literal[0, 1]]`. Represents a Boolean subspace, which is defined by a set of fixed node values.

.. py:data:: ControlOverrides
   :type:  TypeAlias
   :value: list[BooleanSpace]


   Type alias for `list[BooleanSpace]`. Represents a sequence of subspaces, that percolate to targets.

.. py:data:: SubspaceSuccession
   :type:  TypeAlias
   :value: list[BooleanSpace]


   Type alias for `list[BooleanSpace]`. Represents a sequence of subspaces, usually nested.

.. py:class:: Intervention(control: list[biobalm.types.ControlOverrides], strategy: Literal['internal', 'all'], succession: biobalm.types.SubspaceSuccession)

   
   A class for encoding an intervention to a network to reach a target subspace.

   Generally, this class is created by the
   :func:`succession_control<biobalm.control.succession_control>` function,
   which returns a list of `Intervention` objects. Manipulating the
   contents of these objects is only recommended for advanced use cases.
   Typically, it is sufficient to print this object to see a human-readable
   explanation of how to interpret the intervention.

   Note that two interventions are considered to be equal if they act on the same succession with
   equal controls applied to each subspace in the succession. Thus, two
   interventions that override the same nodes in the same way can be
   unequal, even when applied to the same subspaces. This is because each
   subspace imposes a duration condition on the overrides, i.e., the
   override must be maintained until the succession subspace is reached.
   Changing the order of the subspaces considered can alter this stop
   condition.

   :param control: The :class:`ControlOverrides<biobalm.types.ControlOverrides>` objects,
                   in order, that are applied. The order of the list corresponds the
                   order of the subspaces in the succession. Each
                   :class:`ControlOverrides<biobalm.types.ControlOverrides>` object
                   represens a list of overrides, stored as a dictionary of node-value
                   pairs, that drive the system to the corresponding subspace. Each
                   :class:`ControlOverrides<biobalm.types.ControlOverrides>` object is
                   sorted by key value (i.e., alphabetically) upon creation of the
                   `Intervention` object to maintain a canonical ordering.
   :type control: list[ControlOverrides]
   :param strategy: Either "internal" or "all"; "internal" means that the
                    :class:`ControlOverrides<biobalm.types.ControlOverrides>`
   :type strategy: str
   :param succession: A sequence of subspaces that are targeted by the corresponding
                      entries of `control`.
   :type succession: SubspaceSuccession

   .. rubric:: Example

   >>> import biobalm
   >>> sd = biobalm.SuccessionDiagram.from_rules(
   ...     """
   ...     A, B & C
   ...     B, A & C
   ...     C, A & B
   ...     """
   ...     )
   >>> target = {"A": 1, "B": 1, "C": 1}
   >>> interventions = biobalm.control.succession_control(sd, target)
   >>> intervention = interventions[0] # only one in this case
   >>> intervention.control
   [[{'A': 1, 'B': 1}, {'A': 1, 'C': 1}, {'B': 1, 'C': 1}]]
   >>> intervention.strategy
   'internal'
   >>> intervention.succession
   [{'A': 1, 'B': 1, 'C': 1}]
   >>> intervention.successful
   True
   >>> print(intervention)
   Intervention is SUCCESSFUL operating on
   {'A': 1, 'B': 1, 'C': 1}
   override
   ({'A': 1, 'B': 1} or {'A': 1, 'C': 1} or {'B': 1, 'C': 1})


   .. py:property:: control


   .. py:property:: strategy


   .. py:property:: succession


   .. py:property:: successful


.. py:function:: succession_control(succession_diagram: biobalm.succession_diagram.SuccessionDiagram, target: biobalm.types.BooleanSpace, strategy: Literal['internal', 'all'] = 'internal', max_drivers_per_succession_node: int | None = None, forbidden_drivers: set[str] | None = None, successful_only: bool = True) -> list[Intervention]

   Performs succession-diagram control to reach a target subspace.

   :param succession_diagram: The succession diagram from which successions and rules will be
                              extracted.
   :type succession_diagram: SuccessionDiagram
   :param target: The target subspace.
   :type target: BooleanSpace
   :param strategy: The searching strategy to use to look for driver nodes. Options are
                    'internal' (default) and 'all'.
   :type strategy: str, optional
   :param max_drivers_per_succession_node: The maximum number of drivers that will be tested for a succession
                                           diagram node. If `None`, then a number of drivers up to the size of the
                                           succession diagram node's stable motif will be tested
   :type max_drivers_per_succession_node: int | None = None,
   :param forbidden_drivers: A set of forbidden drivers that will not be overridden for control. If
                             `None`, then all nodes are candidates for control.
   :type forbidden_drivers: set[str] | None
   :param successful_only: Whether to only return successful interventions (default: `True`).
   :type successful_only: bool

   :returns: A list of control :class:`Intervention<biobalm.control.Intervention>`
             objects. Note that when `successful_only` is `False`, returned
             interventions may be unsuccessful if `max_drivers_per_succession_node`
             is set too small, or crucial nodes are included in `forbidden_drivers`.
             To test, examine the `successful` property of the intervention.
   :rtype: list[Intervention]

   .. rubric:: Example

   >>> import biobalm
   >>> from biobalm.control import succession_control
   >>> sd = biobalm.SuccessionDiagram.from_rules(
   ...     """
   ...     S, S
   ...     A, S | B
   ...     B, A
   ...     C, A | D
   ...     D, C
   ...     E, false
   ...     """
   ...     )
   >>> target = {"S": 0, "E": 0, "A": 0, "B": 0, "C": 1, "D": 1}
   >>> interventions = succession_control(sd, target, forbidden_drivers = {"A"})
   >>> interventions.sort(key=lambda x: len(x.control)) # to maintain fixed order
   >>> for i in interventions:
   ...     print(f'{i}\n'+'-'*20)
   ...
   Intervention is SUCCESSFUL operating on
   {'S': 0}
   {'A': 0, 'B': 0}
   {'C': 1, 'D': 1}
   override
   ({'S': 0}) and then
   ({'B': 0}) and then
   ({'C': 1} or {'D': 1})
   --------------------
   Intervention is SUCCESSFUL operating on
   {'S': 0}
   {'C': 1, 'D': 1}
   {'A': 0, 'B': 0}
   override
   ({'S': 0}) and then
   ({'C': 1} or {'D': 1}) and then
   ({'B': 0})
   --------------------

   .. rubric:: Example

   >>> import biobalm
   >>> from biobalm.control import succession_control
   >>> sd = biobalm.SuccessionDiagram.from_rules(
   ...         """
   ...     S, S
   ...     A, S | B
   ...     B, A
   ...     C, A | D
   ...     D, C
   ...     E, false
   ...     """
   ...     )
   >>> target = {"S": 0, "E": 0, "A": 0, "B": 0, "C": 1, "D": 1}
   >>> interventions = succession_control(sd, target, strategy = "all")
   >>> interventions.sort(key=lambda x: len(x.control)) # to maintain fixed order
   >>> for i in interventions:
   ...     print(f'{i}\n'+'-'*20)
   ...
   Intervention is SUCCESSFUL operating on
   {'S': 0}
   {'A': 0, 'B': 0}
   {'C': 1, 'D': 1}
   override
   ({'S': 0}) temporarily, and then
   ({'A': 0} or {'B': 0}) temporarily, and then
   ({'C': 1} or {'D': 1})
   --------------------
   Intervention is SUCCESSFUL operating on
   {'S': 0}
   {'C': 1, 'D': 1}
   {'A': 0, 'B': 0}
   override
   ({'S': 0}) temporarily, and then
   ({'A': 1} or {'B': 1} or {'C': 1} or {'D': 1}) temporarily, and then
   ({'A': 0} or {'B': 0})
   --------------------


.. py:function:: successions_to_target(succession_diagram: biobalm.succession_diagram.SuccessionDiagram, target: biobalm.types.BooleanSpace, expand_diagram: bool = True) -> list[biobalm.types.SubspaceSuccession]

   Find lists of nested trap spaces (successions) that lead to the
   specified target subspace.

   Generally, it is not necessary to call this function directly, as it is
   automatically invoked by
   :func:`succession_control<biobalm.control.succession_control>`. It is primarily
   provided in the public API for testing and benchmarking purposes, or in the
   case that the user wants to implement a custom strategy to identify
   succession drivers rather than relying on
   :func:`drivers_of_succession<biobalm.control.drivers_of_succession>`.

   :param succession_diagram: The succession diagram from which successions will be extracted.
   :type succession_diagram: SuccessionDiagram
   :param target: The target subspace.
   :type target: BooleanSpace
   :param expand_diagram: Whether to ensure that the succession diagram is expanded enough to
                          capture all paths to the target (default: True).
   :type expand_diagram: bool

   :returns: A list of successions, where each succession is a list of sequentially
             nested trap spaces that specify the target.
   :rtype: list[SubspaceSuccession]


.. py:function:: drivers_of_succession(bn: biodivine_aeon.BooleanNetwork | biodivine_aeon.AsynchronousGraph, succession: list[biobalm.types.BooleanSpace], strategy: str = 'internal', max_drivers_per_succession_node: int | None = None, forbidden_drivers: set[str] | None = None) -> list[biobalm.types.ControlOverrides]

   Find driver nodes of a list of sequentially nested trap spaces.

   Generally, it is not necessary to call this function directly, as it is
   automatically invoked by
   :func:`succession_control<biobalm.control.succession_control>`. It is primarily
   provided in the public API for testing and benchmarking purposes.

   :param bn: The network to analyze, which contains the Boolean update functions. Ideally,
              the network should be already provided as a symbolic `AsynchronousGraph`.
              Alternatively, a "raw" `BooleanNetwork` can be provided and the symbolic
              `AsynchronousGraph` is created automatically.
   :type bn: BooleanNetwork | AsynchronousGraph
   :param succession: A list of sequentially nested trap spaces that specify the target.
   :type succession: list[BooleanSpace]
   :param strategy: The searching strategy to use to look for driver nodes. Options are
                    'internal' (default) and 'all'.
   :type strategy: str
   :param max_drivers_per_succession_node: The maximum number of drivers that will be tested for a succession
                                           diagram node. If `None`, then a number of drivers up to the size of the
                                           succession diagram node's stable motif will be tested.
   :type max_drivers_per_succession_node: int | None = None,
   :param forbidden_drivers: A set of forbidden drivers that will not be overridden for control. If
                             `None`, then all nodes are candidates for control.
   :type forbidden_drivers: set[str] | None

   :returns: A list of controls. Each control is a list of lists of driver sets,
             represented as state dictionaries. Each list item corresponds to a list
             of drivers for the corresponding trap space in the succession.
   :rtype: list[ControlOverrides]


.. py:function:: find_drivers(bn: biodivine_aeon.BooleanNetwork | biodivine_aeon.AsynchronousGraph, target_trap_space: biobalm.types.BooleanSpace, strategy: str = 'internal', assume_fixed: biobalm.types.BooleanSpace | None = None, max_drivers_per_succession_node: int | None = None, forbidden_drivers: set[str] | None = None) -> biobalm.types.ControlOverrides

   Finds drives of a given target trap space

   Generally, it is not necessary to call this function directly, as it is
   automatically invoked by
   :func:`drivers_of_succession<biobalm.control.drivers_of_succession>`, which in
   turn is invoked by
   :func:`succession_control<biobalm.control.succession_control>`. It is primarily
   provided in the public API for testing and benchmarking purposes.

   :param bn: The network to analyze, which contains the Boolean update functions. Ideally,
              the network should be already provided as a symbolic `AsynchronousGraph`.
              Alternatively, a "raw" `BooleanNetwork` can be provided and the symbolic
              `AsynchronousGraph` is created automatically.
   :type bn: BooleanNetwork | AsynchronousGraph
   :param target_trap_space: The trap space we want to find drivers for.
   :type target_trap_space: BooleanSpace
   :param strategy: The searching strategy to use to look for driver nodes. Options are
                    'internal' (default) and 'all'.
   :type strategy: str
   :param assume_fixed: A dictionary of fixed variables that should be assumed to be fixed.
   :type assume_fixed: dict[str,int] | None
   :param max_drivers_per_succession_node: The maximum number of drivers that will be tested for a succession
                                           diagram node. If `None`, then a number of drivers up to the size of the
                                           succession diagram node's stable motif will be tested.
   :type max_drivers_per_succession_node: int | None = None,
   :param forbidden_drivers: A set of forbidden drivers that will not be overridden for control. If
                             `None`, then all nodes are candidates for control.
   :type forbidden_drivers: set[str] | None

   :returns: A list of internal driver sets, represented as state dictionaries. If
             empty, then no drivers are found. This can happen if
             `max_drivers_per_succession_node` is not `None`, or if all controls
             require nodes in `forbidden_drivers`.
   :rtype: ControlOverrides


.. py:function:: controls_are_equal(a: biobalm.types.ControlOverrides, b: biobalm.types.ControlOverrides) -> bool

   Determine if two :class:`ControlOverrides<biobalm.types.ControlOverrides>`
   objects are equal.

   Two `ControlOverrides` objects are equal if they contain the same
   :class:`BooleanSpace<biobalm.types.BooleanSpace>` objects, regardless of their
   ordering.

   :param a: First :class:`ControlOverrides<biobalm.types.ControlOverrides>` object for
             comparison.
   :type a: ControlOverrides
   :param b: Second :class:`ControlOverrides<biobalm.types.ControlOverrides>` object for
             comparison.
   :type b: ControlOverrides

   :returns: Returns `True` if the two
             :class:`ControlOverrides<biobalm.types.ControlOverrides>` objects are
             equal.
   :rtype: bool


